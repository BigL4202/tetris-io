<!DOCTYPE html>
<html>
<head>
    <title>4x26 IO</title>
    <style>
        body { background: #0a0a0a; color: #fff; font-family: 'Segoe UI', sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; margin: 0; overflow: hidden; }
        #menu { position: absolute; z-index: 100; background: rgba(0,0,0,0.95); width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; }
        button.start-btn { padding: 20px 50px; font-size: 24px; cursor: pointer; background: #00ffcc; border: none; font-weight: bold; margin-top: 10px; border-radius: 5px; transition: 0.2s; }
        button.start-btn:hover { transform: scale(1.05); box-shadow: 0 0 20px #00ffcc; }
        .status { margin-top: 20px; font-size: 18px; color: #888; }
        
        .game-area { display: flex; gap: 50px; transform: scale(0.9); transition: opacity 0.5s; opacity: 0.3; }
        .active { opacity: 1; }
        
        .player-container { display: flex; align-items: flex-end; gap: 10px; position: relative; }
        .main-board-wrap { position: relative; border: 4px solid #333; background: #000; }
        canvas { display: block; }
        .side-col { display: flex; flex-direction: column; justify-content: space-between; height: 780px; }
        .side-box { border: 2px solid #333; background: #000; display: flex; flex-direction: column; align-items: center; padding-top: 5px; }
        .garbage-bar { width: 10px; height: 780px; background: #111; border: 1px solid #333; position: relative; }
        .garbage-fill { position: absolute; bottom: 0; width: 100%; background: #ff0033; transition: height 0.2s; }
        .float-text { position: absolute; left: 50%; transform: translateX(-50%); font-weight: bold; opacity: 0; pointer-events: none; transition: 0.2s; text-align: center; width: 200px; text-shadow: 0 2px 4px rgba(0,0,0,0.8); }
        .win-msg { position: absolute; color: #00ffcc; font-size: 60px; font-weight: bold; text-shadow: 0 0 20px #00ffcc; display: none; z-index: 200; }
        .lose-msg { position: absolute; color: #ff0033; font-size: 60px; font-weight: bold; text-shadow: 0 0 20px #ff0033; display: none; z-index: 200; }
    </style>
    <script src="/socket.io/socket.io.js"></script>
</head>
<body>

    <div id="menu">
        <h1 style="color:#00ffcc; letter-spacing:4px; margin-bottom: 5px;">4x26 IO</h1>
        <button id="find-match-btn" class="start-btn" onclick="findMatch()">FIND MATCH</button>
        <div id="status-msg" class="status"></div>
    </div>

    <div id="win-overlay" class="win-msg">VICTORY</div>
    <div id="lose-overlay" class="lose-msg">DEFEATED</div>

    <div id="game-ui" class="game-area">
        <div class="player-container">
            <div class="garbage-bar"><div id="p1-g" class="garbage-fill"></div></div>
            <div class="side-col">
                <div class="side-box" style="height:80px">HOLD<canvas id="p1-h" width="60" height="50"></canvas></div>
                <div id="p1-b2b" class="float-text" style="top:120px; color:#0cf">B2B</div>
                <div id="p1-combo" class="float-text" style="top:150px; color:#fc0">COMBO</div>
            </div>
            <div class="main-board-wrap">
                <div style="position:absolute; top:-25px; width:100%; text-align:center; color:#0cf">YOU</div>
                <canvas id="p1" width="120" height="780"></canvas>
            </div>
            <div class="side-col"><div class="side-box" style="height:200px">NEXT<canvas id="p1-n" width="60" height="180"></canvas></div></div>
        </div>

        <div class="player-container">
            <div class="garbage-bar"><div id="p2-g" class="garbage-fill"></div></div>
            <div class="main-board-wrap">
                <div style="position:absolute; top:-25px; width:100%; text-align:center; color:#f0f">OPPONENT</div>
                <canvas id="p2" width="120" height="780"></canvas>
            </div>
        </div>
    </div>

    <script>
        const socket = io();
        let myRoom = null;
        let gameRunning = false;
        
        // Game Constants
        const COLS = 4, ROWS = 26, B_SIZE = 30;
        const PIECES = [[[1,1,1,1]],[[1,1],[1,1]],[[0,1,0],[1,1,1]],[[1,1,0],[0,1,1]],[[0,1,1],[1,1,0]],[[1,0,0],[1,1,1]],[[0,0,1],[1,1,1]]];

        // --- MATCHMAKING ---
        function findMatch() {
            document.getElementById('find-match-btn').style.display = 'none';
            document.getElementById('status-msg').innerText = "Searching for opponent...";
            socket.emit('join_game');
        }

        socket.on('waiting', () => {
            document.getElementById('status-msg').innerText = "Waiting for another player...";
        });

        socket.on('match_start', (data) => {
            myRoom = data.room;
            document.getElementById('menu').style.display = 'none';
            document.getElementById('game-ui').classList.add('active');
            gameRunning = true;
            localPlayer.reset();
            loop();
        });

        socket.on('receive_garbage', (amount) => {
            localPlayer.pendingG += amount;
            localPlayer.updateUI();
        });

        socket.on('enemy_board', (grid) => {
            enemyPlayer.renderGrid(grid);
        });

        socket.on('game_won', () => {
            gameRunning = false;
            document.getElementById('win-overlay').style.display = 'block';
        });

        // --- LOCAL GAME ENGINE ---
        class Player {
            constructor(id, nId, hId, gId) {
                this.ctx = document.getElementById(id).getContext('2d');
                this.nCtx = document.getElementById(nId).getContext('2d');
                this.hCtx = document.getElementById(hId).getContext('2d');
                this.gBar = document.getElementById(gId);
                this.grid = Array.from({length: ROWS}, () => Array(COLS).fill(0));
                this.bag = []; this.queue = []; this.holdId = null; this.canHold = true;
                this.pendingG = 0; this.combo = -1; this.b2b = 0;
                this.active = null; this.dropCounter = 0;
            }

            reset() {
                this.grid.forEach(r => r.fill(0));
                this.bag = []; this.queue = [];
                for(let i=0; i<4; i++) this.queue.push(this.pullBag());
                this.spawn();
            }

            pullBag() { 
                if(!this.bag.length){this.bag=[0,1,2,3,4,5,6]; this.bag.sort(()=>Math.random()-0.5);} 
                return this.bag.pop(); 
            }

            spawn(id = this.queue.shift()) {
                this.queue.push(this.pullBag());
                this.active = { pos: {x: 0, y: 0}, matrix: PIECES[id], id: id, color: `hsl(${id*50},100%,60%)` };
                
                if(this.collide()){ 
                    socket.emit('player_lost', myRoom);
                    document.getElementById('lose-overlay').style.display = 'block';
                    gameRunning = false;
                }
                
                this.drawSide(this.nCtx, this.queue);
                this.sendBoardUpdate();
            }

            sendBoardUpdate() {
                // Send simplified grid to server for enemy to see
                // We combine the locked grid + active piece for visual clarity
                const displayGrid = JSON.parse(JSON.stringify(this.grid));
                this.active.matrix.forEach((r,y)=>r.forEach((v,x)=>{ 
                    if(v && displayGrid[y+this.active.pos.y] && displayGrid[y+this.active.pos.y][x+this.active.pos.x] !== undefined) 
                        displayGrid[y+this.active.pos.y][x+this.active.pos.x] = this.active.color; 
                }));
                socket.emit('update_board', { room: myRoom, grid: displayGrid });
            }

            collide(m=this.active.matrix, p=this.active.pos) {
                for(let y=0;y<m.length;y++) for(let x=0;x<m[y].length;x++)
                    if(m[y][x] && (this.grid[y+p.y]===undefined || this.grid[y+p.y][x+p.x]===undefined || this.grid[y+p.y][x+p.x])) return true;
                return false;
            }

            rotate() {
                const rotated = this.active.matrix[0].map((_,i)=>this.active.matrix.map(row=>row[i]).reverse());
                const kicks = [0, -1, 1, -2];
                for(let k of kicks) { 
                    if(!this.collide(rotated, {x:this.active.pos.x+k, y:this.active.pos.y})){ 
                        this.active.pos.x+=k; this.active.matrix=rotated; 
                        this.sendBoardUpdate();
                        return; 
                    } 
                }
            }

            move(dir) {
                this.active.pos.x += dir; 
                if(this.collide()) this.active.pos.x -= dir;
                this.sendBoardUpdate();
            }

            drop() {
                this.active.pos.y++;
                if(this.collide()) { this.active.pos.y--; this.lock(); }
                this.dropCounter = 0;
                this.sendBoardUpdate();
            }

            hardDrop() { while(!this.collide()) this.active.pos.y++; this.active.pos.y--; this.lock(); }

            lock() {
                this.active.matrix.forEach((r,y)=>r.forEach((v,x)=>{ if(v) this.grid[y+this.active.pos.y][x+this.active.pos.x]=this.active.color; }));
                this.sweep(); 
                this.canHold=true; 
                this.spawn();
            }

            sweep() {
                let lines=0;
                for(let y=ROWS-1;y>=0;y--) if(this.grid[y].every(v=>v!==0)){ this.grid.splice(y,1); this.grid.unshift(Array(COLS).fill(0)); lines++; y++; }
                
                if(lines > 0) {
                    this.combo++;
                    let atk = lines===4?4:lines-1; 
                    atk += Math.floor(this.combo/2);
                    
                    if(this.pendingG > 0){ let c=Math.min(this.pendingG,atk); this.pendingG-=c; atk-=c; }
                    
                    if(atk > 0) socket.emit('send_garbage', { room: myRoom, amount: atk });
                    
                    this.updateUI();
                } else {
                    this.combo = -1;
                    while(this.pendingG > 0){ 
                        this.pendingG--; 
                        let r=Array(COLS).fill('#555'); r[Math.floor(Math.random()*COLS)]=0; 
                        this.grid.shift(); this.grid.push(r); 
                    }
                }
                this.sendBoardUpdate();
            }

            hold() {
                if(!this.canHold) return;
                const cur = this.active.id;
                if(this.holdId===null){ this.holdId=cur; this.spawn(); } else { const t=this.holdId; this.holdId=cur; this.spawn(t); }
                this.canHold=false; this.drawSide(this.hCtx, [this.holdId]);
            }

            updateUI() {
                this.gBar.style.height = (this.pendingG * 30) + 'px';
            }

            drawSide(ctx, ids) {
                ctx.fillStyle='#000'; ctx.fillRect(0,0,60,180);
                ids.forEach((id,i)=>{ if(id!==null){ ctx.fillStyle=`hsl(${id*50},100%,60%)`; PIECES[id].forEach((r,y)=>r.forEach((v,x)=>{ if(v) ctx.fillRect(x*12+8, y*12+i*50+10, 11, 11); })); }});
            }

            draw() {
                this.ctx.fillStyle='#000'; this.ctx.fillRect(0,0,120,780);
                this.grid.forEach((r,y)=>r.forEach((v,x)=>{ if(v){ this.ctx.fillStyle=v; this.ctx.fillRect(x*B_SIZE, y*B_SIZE, B_SIZE-1, B_SIZE-1); }}));
                // Active Piece
                if(this.active) {
                    let g={...this.active.pos}; while(!this.collide(this.active.matrix,g)) g.y++; g.y--;
                    this.ctx.fillStyle='rgba(255,255,255,0.15)';
                    this.active.matrix.forEach((r,y)=>r.forEach((v,x)=>{ if(v) this.ctx.fillRect((g.x+x)*B_SIZE, (g.y+y)*B_SIZE, B_SIZE-1, B_SIZE-1); }));
                    this.ctx.fillStyle=this.active.color;
                    this.active.matrix.forEach((r,y)=>r.forEach((v,x)=>{ if(v) this.ctx.fillRect((this.active.pos.x+x)*B_SIZE, (this.active.pos.y+y)*B_SIZE, B_SIZE-1, B_SIZE-1); }));
                }
            }
        }

        // --- ENEMY RENDERER ---
        class Enemy {
            constructor() {
                this.ctx = document.getElementById('p2').getContext('2d');
            }
            renderGrid(grid) {
                this.ctx.fillStyle='#000'; this.ctx.fillRect(0,0,120,780);
                if(!grid) return;
                grid.forEach((r,y)=>r.forEach((v,x)=>{ if(v){ this.ctx.fillStyle=v; this.ctx.fillRect(x*B_SIZE, y*B_SIZE, B_SIZE-1, B_SIZE-1); }}));
            }
        }

        const localPlayer = new Player('p1', 'p1-n', 'p1-h', 'p1-g');
        const enemyPlayer = new Enemy();

        // CONTROLS (Arrows / Space / Shift)
        document.addEventListener('keydown', e => {
            if(!gameRunning) return;
            const k = e.code;
            if(k==='ArrowLeft') localPlayer.move(-1);
            if(k==='ArrowRight') localPlayer.move(1);
            if(k==='ArrowUp') localPlayer.rotate();
            if(k==='ArrowDown') localPlayer.drop();
            if(k==='Space') localPlayer.hardDrop();
            if(k==='ShiftLeft') localPlayer.hold();
            if(['Space','ArrowUp','ArrowDown'].includes(k)) e.preventDefault();
        });

        let lastTime = 0;
        function loop(time = 0) {
            const dt = time - lastTime; lastTime = time;
            if(gameRunning) {
                localPlayer.dropCounter += dt;
                if(localPlayer.dropCounter > 700) { 
                    localPlayer.active.pos.y++; 
                    if(localPlayer.collide()){localPlayer.active.pos.y--; localPlayer.lock();} 
                    localPlayer.dropCounter=0; 
                    localPlayer.sendBoardUpdate();
                }
                localPlayer.draw();
            }
            requestAnimationFrame(loop);
        }
    </script>
</body>
</html>